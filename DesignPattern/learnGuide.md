# 《python设计模式》

## 第一章 设计模式简介
### 1.1 理解面向对象编程
面向对象的世界引入了对象的概念，而这些对象又具有属性属性（数据成员）
和过程（成员函数）。这些函数的作用就是处理属性。
在Python中，一切皆对象，每个类的实例或变量都有它自己的内存地址或身份。
对象就是类的实例，应用开发就是通过让对象交互来实现目的的过程。
#### 1.1.1 对象
* 他们表示所开发的应用程序内的实体
* 实体之间可以通过交互来解决现实世界的问题。

例如，Person是实体，而Car也是实体。Person可以驾驶Car，从一个地方开到另一个地方。
#### 1.1.2 类
类可以帮助开发人员表示现实世界中的实体。
* 类可以定义对象的属性和行为。属性是数据成员，行为由成员函数表示。
* *类包含了构造函数，这些函数的作用是为对象提供初始状态。*
* 类就像模板一样，非常易于重复使用。

例如，类Person可以带有属性name和age，同时提供成员函数gotoOffice()，以定义去办公室的行为。
#### 1.1.3 方法
方法在面向对象世界中的作用：
* 它们表示对象的行为。
* 方法可以对属性进行处理，从而实现所需的功能。
创建类和对象的例子
```
class Person(object):
    def __init__(self, name, age):    # constructor
        self.name = name    # data members/ attributes
        self.age = age
    def get_person(self, ):    # member function
        return "<Person (%s, %s)>" % (self.name, self.age)
    
p = Person("John", 32)    # p is an object of type Person
print("Type of Object:", type(p), "Memory Address:", id(p))
```
上述代码输出结果如下：
```
Type of Object: <class '__main__.Person'> Memory Address: 4378733296
```
[代码版本：Python v3.8.0](./相关代码/第一章/1.1.3.py)

### 1.2 面向对象编程的主要概念
#### 1.2.1 封装
主要特点：
* 对象的行为对于外部世界来说是不可见的，或者说对象的状态信息是私密的。
* 客户端不能通过直接操作来改变对象的内部状态。
相反，客户端需要通过发送消息来请求兑现改变其内部状态。
对象可以根据请求的类型，通过特定的成员函数（例如get和set）
改变它们的内部状态，以做出相应的响应。
* 在Python中，封装（数据和方法的隐藏）的概念不是隐式的，
因为它没有提供封装所需的关键字，诸如public，private，protected
（在诸如C++或Java之类语言中，都提供了这类关键字）。
但在变量和函数名前面加上前缀_(protected)或__(private)，就可以达到相同效果
#### 1.2.2 多态
主要特征：
* 多态有两种类型：
    - 对象根据输入参数提供方法的不同实现。
    - 不同类型的对象可以使用相同的接口。
* 对于Python来说，多态是该语言的内置功能。
例如，操作符“+”可以应用于两个整数以进行假发运算，也可以应用于字符串来连接它们。
字符串、元组、列表都可以通过整数索引进行访问，这展示了Python内置类型的多态：
```
a = "John"
b = (1, 2, 3)
c = [1, 3, 4, 6, 8, 10]
print(a[2], b[0], c[3])
```
以上代码输出如下:
```
h 1 6
```
[代码版本：Python v3.8.0](./相关代码/第一章/1.2.2.py)

#### 1.2.3 继承
* 继承表示一个类可以继承父类的（大部分）功能。
* 继承被描述为一个重用基类中定义的功能并允许对原始软件的实现进行独立扩展的选项。
* 继承可以利用不同类的对象之间的关系建立层次结构。
与Java不同，Python支持多重继承（继承多个基类）

继承示例：
```
class A:
    def a1(self):
        print("a1")
    
class B(A):
    def b(self):
        print("b")

b = B()
b.a1()
```
输出：
```
a1
```
[代码版本：Python v3.8.0](./相关代码/第一章/1.2.3.py)

#### 1.2.4 抽象
主要特征：
* 它提供了一个简单的客户端接口，客户端可以通过该接口与类的对象进行交互，
并可以调用该接口中定义的各个方法。
* 它将内部类的复杂性抽象为一个接口，这样客户端就不需要知道内部实现了。
下面例子，我们通过add()方法对类Adder的内部细节进行了抽象处理：
```
class Adder:
    def __init__(self):
        self.sum = 0
    def add(self, value):
        self.sum += value

acc = Adder()
for i in range(100):
    acc.add(i)

print(acc.sum)
```
输出：
```
4950
```
[代码版本：Python v3.8.0](./相关代码/第一章/1.2.4.py)

#### 1.2.5 组合
* 它是一种将对象或者类组合成更复杂的数据结构或软件实现的方法。
* 在组合中，一个对象可用于调用其他模块中的成员函数，这样一来，
无需通过继承就可以实现基本功能的跨模块使用。
下面示例中，类A的对象被组合到了类B中：
```
class A(object):
    def a1(self):
        print("a1")

class B(object):
    def b(self):
        print("b")
        A().a1()

objectB = B()
objectB.b()
```
输出:
```
b
a1
```
[代码版本：Python v3.8.0](./相关代码/第一章/1.2.5.py)

### 1.3 面向对象的设计原则
当我们深入细致地学习设计模式时，面向对象的设计原则将作为工具箱使用
#### 1.3.1 开放/封闭原则
开放/封闭原则规定，类或者对象及其方法对于扩展来说，应该是开放的，
但是对于修改来说，应该是封闭的。
简单地说，这意味着当你开发软件应用的时候，一定确保以通用的方式来编写类或模块，
以便每当需要扩展类或对象行为的时候不必修改类本身。
相反，类的简单扩展将有助于建立新的行为。
例如，开放/封闭原则能够在下列情形中表现的淋漓尽致：为了实现所需行为，
用户必须通过扩展抽象基类来创建类的实现，而不是通过修改抽象类。
该设计原则的优点如下：
* 现有的类不会被修改，因此退化的可能性较小。
* 它还有助于保持以前代码的向后兼容性。
#### 1.3.2 控制反转原则
控制反转原则是指，高层级的模块不应该依赖于低层级的模块，
它们都应该依赖于抽象。
细节应该依赖于抽象，而不是抽象依赖于细节。
该原则建议任何两个模块都不应该以紧密方式相互依赖。事实上，
基本模块和从属模块应当在它们之间提供一个抽象层来耦合。
这个原则还建议，类的细节应该描绘抽象。

在某些情况下，这种观念会反转，也就是实现细节本身决定了抽象，这种情况是应该避免的。

控制反转原则的优点如下：
* 削弱了模块间的紧耦合，因此消除了系统中的复杂性/刚性。
* 由于在依赖模块之间有一个明确的抽象层（由钩子或者参数提供），
因此便于通过更好的方式处理模块之间的依赖关系。

#### 1.3.3 接口隔离原则
接口隔离原则规定，客户端不应该依赖于它们不需要使用的接口。
接口隔离原则的意思就是，软件开发人员应该仔细地处理接口。
例如，它提醒开发人员/架构师开发的方法要与特定功能紧密相关。
如果存在与接口无关的方法，那么依赖于该接口的类就必须实现它，实际上这是毫无必要的。
例如，一个Pizza接口不应该提供名为add_chicken()的方法。
基于Pizza结构的Veg Pizza类不应该强制实现该方法。
该设计原则优点：
* 他强制开发人员编写“瘦身型”接口，并使方法与接口紧密相关。
* 防止向接口中随意添加方法。

#### 1.3.4 单一职责原则
单一职责的含义是：类的职责单一，引起类变化的原因单一。
这个原则是说，当我们开发类时，它应该为特定的功能服务。
如果一个类实现了两个功能，那么最好将它们分开。
也就是说，功能才是改变的理由。
例如，一个类可以因为所需行为的变化而进行修改，
但是如果一个类由于两个因素(基本上是两个功能的改变)而改变，
那么该类就应该进行相应的分割。
该设计原则的优点：
* 每当一个功能发生变化时，除了特定的类需要改变外，其他类无需变动。
* 此外，如果一个类有多种功能，那么依赖它的类必定会由于多种原因
而经历多次修改，这是应该避免的。

#### 1.3.5 替换原则
替换原则规定，派生类必须能够完全取代基类。
这个原则很简单，当应用程序开发人员编写派生类时，该原则的含义就是他们应该扩展基类。
此外，它还建议派生类应该尽可能对基类封闭，以至于派生类本身可以替换基类，
而无需修改任何代码。

### 1.4 设计模式的概念
什么是设计模式呢？
根据GoF的观点，设计模式就是解决特定问题的解决方案。
设计模式本身是一种发现，而不是一种发明。
设计模式的主要特点：
* 它们是语言无关的，可以用多种语言实现。
* 它们是动态的，随时会有新的模式引入。
* 它们可以进行定制，因此对开发人员非常有用。

你必须尝试解决设计模式想要解决的问题，也许你的解决方案并不完善，
而我们所追求的完善性正是设计模式中固有的或隐含的。
当我们提到完整性时，它可以指许多因素。例如，设计、可扩展性、
重用、内存利用率等。从本质上说，设计模式就是从别人的成功而非
自己的失败中进行学习！
关于设计模式的另一个有趣的讨论是，什么时候使用他们？他是应用在
软件开发生命周期（Software Development Life Cycle，SDLC）
的分析或设计阶段吗？
有趣的是，设计模式是已知问题的解决方案。
因此设计模式在分析或设计阶段非常有用，并且如预期的那样，
在开发阶段也非常有用，因为他们与应用的编程直接相关。
#### 1.4.1 设计模式的优点
* 它们可以在多个项目中重复使用。
* 问题可以在架构级别得到解决。
* 它们都经过了时间的验证和良好的证明，是开发人员和架构师的宝贵经验。
* 它们具有可靠性和依赖性。
#### 1.4.2 设计模式的分类
不是每一段代码或者每一种设计都可以叫做设计模式。
例如，解决一个问题的编程构造或数据结构就不能被称为模式。
下面通过一种简单的方式来理解这些术语。
* 代码段：用某种语言编写的一段具有特定用途的代码，例如，他可以是Python
中的DB连接代码。
* 设计：用来解决某个特定问题的优秀解决方案。
* 标准：这是一种解决某类问题的方法，它非常通用，并适用于当前的情况。
* 模式：这是一个经过时间考验的、高效、可扩展的解决方案，能够解决一类已知问题。
#### 1.4.3 上下文--设计模式的适用性
为了有效使用设计模式，应用程序开发人员必须了解设计模式所适用的上下文。
我们可以将上下文分为以下几种主要类型：
* 参与者：它们是在设计模式中用到的类。类可以在模式中扮演不同的角色，以完成多个目标。
* 非功能需求：诸如内存优化、可用性和性能等需求都属于此类型。
由于这些因素影响整个软件解决方案，因此至关重要。
* 权衡：并非所有的设计模式都适合于应用程序开发，因此需要权衡。
这些是在应用程序中使用谁模式时所做的决策。
* 结果：如果上下文不合适，设计模式可能对代码的其他部分产生负面影响。
开发人员应该了解设计模式的结果和用途。
### 1.5 动态语言的设计模式
就像Lisp一样，Python也是一种动态语言。
Python动态特性如下：
* 类型或类是运行时对象。
* 变量可以根据赋值来确定类型，并且类型可以在运行时改变。例如，
a=5和a="john"，变量a在运行时被赋值，而且其类型也发生了变化。
* 动态语言在类限制方面具有更大的灵活性。
例如，在Python中，多态性是该语言所固有的，并没有诸如private
和protected之类的关键字，因为默认情况下一切都是公共的。
* 可以使用动态语言轻松实现设计模式的用例。
### 1.6 模式的分类
GoF在他的设计模式中讲到了23种设计模式，并将它们分为3大类。
* 创建型模式
* 结构型模式
* 行为型模式

模式的分类主要基于对象的创建方式、软件应用程序中类和对象的构造方式，
同时还涉及对象之间的交互方式。
#### 1.6.1 创建型模式
创建型模式的性质：
* 它们的运行机制基于对象的创建方式。
* 它们将对象创建的细节隔离开来。
* 代码与所创建的对象的类型无关。

单例模式是创建型模式的一个例子。
#### 1.6.2 结构型模式
结构型模式的性质：
* 它们致力于设计出能够通过组合获得更强大功能的对象和类的结构。
* 重点是简化结构并识别类和对象之间的关系。
* 它们主要关注类的继承和组合。

适配器模式是结构型模式的一个例子。
#### 1.6.3 行为型模式
行为型模式的性质：
* 它们关注对象之间的交互以及对象的响应性。
* 对象应该能够交互，同时仍然保持松散耦合。

观察者模式是行为模式的一个例子。
## 第二章 单例设计模式
单例设计模式是应用开发过程中最简单和最著名的一种创建型设计模式。
本章还会介绍Monostate（或者Borg）设计模式，它是单例设计模式的一个变种。
本章涉及主题：
* 理解单例设计模式
* 单例模式实例
* 单例设计模式的Python实现
* Monostate（Borg）模式
### 2.1 理解单例设计模式
单例模式提供了这样一个机制，即确保类有且只有一个特定类型的对象，并提供全局访问点。
因此，单例模式通常用于下列情形，例如日志记录或数据库操作、打印机后台处理程序，
以及其他程序---该程序运行过程中只能生成一个实例，以避免对同一资源产生相互冲突的请求。
例如，我们可能希望使用一个数据库对象对数据库进行操作，以维护数据的一致性；
或者希望一个日志类的对象，将多项服务的日志信息按照顺序转储存到一个特定的日志文件中。
简言之，单例模式特点如下：
* 确保类有且只有一个对象被创建。
* 为对象提供一个访问点，以使用程序可以全局访问该对象。
* 控制共享资源的并行访问。

实现单例模式的一个简单地方法是，使构造函数私有化，并创建一个静态方法来完成对象的初始化。
这样，对象在第一次调用时创建，此后这个类将返回同一个对象。
在使用Python的时候，我们实现方式要有所变通，因为它无法创建私有的构造函数。
#### 利用Python实现经典的单例模式
下面是基于Python的单例模式实现代码，它主要完成了两件事情。
1. 只允许Singleton类生成一个实例。
2. 如果已经有了一个实例了，我们会重复提供同一个对象。
具体代码如下:
```
class Singleton(object):
    def __new__(cls):
        if not hasattr(cls, 'instance'):
            cls.instance = super().__new__(cls)
        return cls.instance

s = Singleton()
print('Object created', s)

s1 = Singleton()
print('Object created', s1)
```
输出
```
Object created <__main__.Singleton object at 0x107b051f0>
Object created <__main__.Singleton object at 0x107b051f0>
<__main__.Singleton object at 0x10a1af1f0>
```
[代码版本：Python v3.8.0](./相关代码/第二章/2.1.py)

在上面的代码中，我们通过覆盖`__new__`方法（Python用于实例化对象的特殊方法）
来控制对象的创建。对象s就是由`__new__`方法创建的，但在创建之前，
该方法会检查对象是否已存在。
方法hasattr（Python的特殊方法，用来了解对象是否具有某个属性）
用于查看对象cls是否具有属性instance，该属性的作用是检查该类是否已经生成了一个对象。
当对象s1被请求的时候，hasattr()发现对象已经存在，
所以，对象s1将被分配已有的对象实例（地址位于0x10a1af1f0）
### 2.2 单例模式中的懒汉式实例化
单例模式的用例之一就是懒汉式实例化。例如，再导入模块的时候我们可能会无意中创建一个对象，
但当时根本用不到它。懒汉式实例化能够确保在实际需要时才创建对象。
所以，懒汉式实例化是一种节约资源并仅在需要时才创建它们的方式。

在下面的代码示例中，执行`s = Singleton()`的时候，它会调用`__init__`方法，
但没有新的对象被创建。然而，实际的对象创建发生在调用`Singleton.getInstance()`
的时候，我们正是通过这种方式来实现懒汉式实例化的。

```
class Singleton:
    __instance = None
    def __init__(self):
        if not Singleton.__instance:
            print(" __init__method called..")
        else:
            print("Instance already created:", self.getInstance())
    @classmethod
    def getInstance(cls):
        if not cls.__instance:
            cls.__instance = Singleton()
        return cls.__instance
    
s = Singleton()  ## class initialized, but object not created
print('*' * 80)
print("Object created", Singleton.getInstance())  # Object gets created here
print('*' * 80)
s1 = Singleton()  ## instance already created
```
输出：
```
 __init__method called..
********************************************************************************
 __init__method called..
Object created <__main__.Singleton object at 0x106330250>
********************************************************************************
Instance already created: <__main__.Singleton object at 0x106330250>
```
[代码版本：Python v3.8.0](./相关代码/第二章/2.2.py)

### 2.3 模块级别的单例模式
默认情况下，所有模块都是单例，这是由Python的导入行为所决定的。
Python通过下列方式来工作。
1. 检查一个Python模块是否已经导入。
2. 如果已经导入，则返回该模块的对象。
如果还没有导入，则导入该模块，并实例化。
3. 因此，当模块被导入的时候，它就会被实例化。然而，当同一个模块被再次导入的时候，
它不会再次初始化，因为单例模式只能有一个对象，所以，它会返回同一个对象。
### 2.4 Monostate单例模式
GoF的单例设计模式是指，一个类有且只有一个对象。
根据Alex Martelli的说法，通常程序员需要的是让实例共享相同的状态。
他建议开发人员应该关注状态和行为，而不是同一性。
由于该概念基于所有对象共享相同状态，因此它也被称为Monostate（单态）模式。
Monostate模式可以通过Python轻松实现。在下面的代码中，我们将类变量
`__shared_state`赋给变量`__dict__`（它是Python的一个特殊变量）。
Python使用`__dict__`存储一个类所有对象的状态。在下面的代码中，
我们故意把`__shared_state`赋给所有已经创建的实例。
所以，如果我们创建了两个实例“b”和“b1”，我们将得到两个不同的对象，
这一点与单例模式大为不同，后者只能生成一个对象。
然而对象的状态即`b.__dict__`和`b1.__dict__`却是相同的。
现在，就算对象b的对象变量x发生了变化，这个变化也会复制到被所有对象共享
的`__dict__`变量，即b1的变量x的值也会从1变为4。
```
class Borg:
    __shared_state = {"1" : "2"}
    def __init__(self):
        self.x = 1
        self.__dict__ = self.__shared_state
        pass

b = Borg()
b1 = Borg()
b.x = 4
print("Borg Object 'b': ", b)  ## b and b1 are distinct objects
print("Borg Object 'b1': ", b1)
print("Object State 'b': ", b.__dict__)  ## b and b1 share same state
print("Object State 'b1': ", b1.__dict__)
```
输出
```
Borg Object 'b':  <__main__.Borg object at 0x1097ff6a0>
Borg Object 'b1':  <__main__.Borg object at 0x1097f8940>
Object State 'b':  {'1': '2', 'x': 4}
Object State 'b1':  {'1': '2', 'x': 4}
```
[代码版本：Python v3.8.0](./相关代码/第二章/2.4.1.py)

除此以外，我们还可以通过修改`__new__`方法本身来实现Borg模式。
我们知道，`__new__`方法是用来创建对象的实例的，具体如下所示：
```
class Borg(object):
    _shared_state = {}
    def __new__(cls, *args, **kwargs):
        obj = super().__new__(cls, *args, **kwargs)
        obj.__dict__ = cls._shared_state
        return obj
b = Borg()
b1 = Borg()
b.x = 4
print("Borg Object 'b': ", b)  ## b and b1 are distinct objects
print("Borg Object 'b1': ", b1)
print("Object State 'b': ", b.__dict__)  ## b and b1 share same state
print("Object State 'b1': ", b1.__dict__)
```
输出：
```
Borg Object 'b':  <__main__.Borg object at 0x1017021f0>
Borg Object 'b1':  <__main__.Borg object at 0x101702220>
Object State 'b':  {'x': 4}
Object State 'b1':  {'x': 4}
```
[代码版本：Python v3.8.0](./相关代码/第二章/2.4.2.py)

### 2.5 单例和元类
元类是一个类的类，这意味着该类是它的元类的实例。使用元类，
程序员有机会从预定义的Python类创建自己类型的类。例如，你有一个
对象MyClass，你可以创建一个元类MyKls,它按照你需要的方式重新定义
MyClass的行为。下面，来深入介绍它们。
在Python中，一切皆对象。如果我们说`a=5`，则`type(a)`返回
`<type'int'>`，这意味着a是int类型。
但是，`type(int)`返回`<type'type'>`，这表明存在一个元类，
因为int是type类型的类。
类的定义由它的元类决定，所以当我们用类A创建一个类时，Python
通过`A=type(name, bases, dict)`创建它。
* name: 这是类的名称
* bases: 这是基类
* dict: 这是属性变量

现在，如果一个类有一个预定义的元类（名为Metals），那么Python就会通过
`A=Metals(name, bases, dict)`来创建这个类。
让我们看看一个示例元类的实现：
```
class MyInt(type):
    def __call__(cls, *args, **kwds):
        print("***** Here's My int *****", args)
        print("Now do whatever you want with these objects...")
        return type.__call__(cls, *args, **kwds)
    
class int(metaclass=MyInt):
    def __init__(self, x, y):
        self.x = x
        self.y = y

i = int(2, 7)
```
输出：
```
***** Here's My int ***** (2, 7)
Now do whatever you want with these objects...
```
[代码版本：Python v3.8.0](./相关代码/第二章/2.5.1.py)

对于已经存在的类来说，当需要创建对象时，将调用Python的特殊方法`__call__`。
在这段代码中，当我们使用int(2,7)实例化int类时，MyInt元类的`__call__`方法
将被调用，这意味着现在元类控制着对象的实例化。

前面的思路同样适用于单例设计模式。由于元类对类创建和对象实例化有更多的控制权，
所以它可以用于创建单例。（注意：为了控制类的创建和初始化，
元类将覆盖`__new__`和`__init__`方法。）

以下示例代码能够更好地帮我们解释基于元类的单例实现：
```
class MetaSingleton(type):
    _instances = {}
    def __call__(cls, *args, ** kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super().__call__(*args, **kwargs)
            print(super(),cls,'+',cls._instances)
        return cls._instances[cls]
    
class Logger(metaclass=MetaSingleton):
    pass

logger1 = Logger()
logger2 = Logger()
print(logger1, logger2)
```
输出：
```
<super: <class 'MetaSingleton'>, <MetaSingleton object>> <class '__main__.Logger'> + {<class '__main__.Logger'>: <__main__.Logger object at 0x108590250>}
<__main__.Logger object at 0x108590250> <__main__.Logger object at 0x108590250>
```
[代码版本：Python v3.8.0](./相关代码/第二章/2.5.2.py)

### 2.6 单例模式一
作为一个实际的用例，我们将通过一个数据库应用程序来展示单例的应用。
这里不妨以需要对数据库进行多种读取和写入操作的云服务为例进行讲解。
完整的云服务被分解为多个服务，每个服务执行不同的数据库操作。
针对UI（Web应用程序）上的操作将导致调用API,最终产生相应的DB操作。
很明显，跨不同服务的共享资源是数据库本身。
因此如果我们需要更好地设计云服务，必须注意以下几点：
* 数据库中操作的一致性，即一个操作不应与其他操作发生冲突。
* 优化数据库的各种操作，以提高内存和CPU的利用率。
这里提供一个示例Python实现：
```
import sqlite3
class MetaSingleton(type):
    _instances = {}
    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super().__call__(*args, **kwargs)
        return cls._instances[cls]
    
class Database(metaclass=MetaSingleton):
    connection = None
    def connect(self):
        if self.connection is None:
            self.connection = sqlite3.connect("db.sqlite3")
            self.cursorobj = self.connection.cursor()
        return self.cursorobj

db1 = Database().connect()
db2 = Database().connect()

print("Database Objects DB1", db1)
print("Database Objects DB2", db2)
```
输出：
```
Database Objects DB1 <sqlite3.Cursor object at 0x10e877f80>
Database Objects DB2 <sqlite3.Cursor object at 0x10e877f80>
```
[代码版本：Python v3.8.0](./相关代码/第二章/2.6.py)

通过阅读上面的代码，我们会发现以下几点。
1. 我们以MetaSingleton为名创建了一个元类。就像在上一节中解释的那样，
Python的特殊方法`__call__`可以通过元类创建单例。
2. 数据库类由MetaSingleton类装饰后，其行为就会表现为单例。因此，当
数据库类被实例化时，它只能创建一个对象。
3. 当Web应用程序对数据库执行某些操作时，它会多次实例化数据库类，但只创建一个对象。
因为只有一个对象，所以对数据库的调用是同步。此外，这样还能够节约系统资源，并且可以
避免消耗过多的内存或CPU资源。

假如我们要开发的不是单个Web应用程序，而是集群化的情形，即多个Web应用共享单个数据库。

当然，单例在这种情况下好像不太好使，因为每增加一个Web应用程序，就要新建一个单例，
添加一个新的对象来查询数据库。

这导致数据库操作无法同步，并且要耗费大量的资源。
在这种情况下，数据库的链接池比实现单例要好得多。

### 2.7 单例模式二
让我们考虑另一种情况，即为基础设施提供运行状况监控服务（就像Nagios所做的那样）。

我们创建了HealthCheck类，它作为单例实现。我们还要维护一个被监控的服务器列表。

当一个服务器从这个列表中删除时，监控软件应该觉察到这一情况，并从被监控的服务器
列表中将其删除。

在下面的代码中，hc1和hc2对象与单例中的类相同。
我们可以使用`addServer()`方法将服务器添加到基础设施中，以进行运行状况检查。

首先，通过迭代对这些服务器的运行状况进行检查。之后，`changeServer()`方法

会删除最后一个服务器，并向计划进行运行状况检查的基础设施中添加一个新服务器。

因此，运行状况检查进行第二次迭代时，它会使用修改后的服务器列表。

所有这一切都可以借助单例模式来完成。当添加或删除服务器时，运行状况的检查工作
必须由了解基础设施变动情况的同一个对象来完成：
```
```
输出：
```
```























