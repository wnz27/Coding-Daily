# 《Python编程：从入门到实践》
Python_preToPractice

---

- [函数](#函数)
    - [规范](#规范)
    - [传递参数](#传递参数)
        - [默认值](#默认值)
        - [title()](#title)
        - [实现实参可选](#实现实参可选)
    - [传递列表](#传递列表)
        - [禁止函数修改列表](#禁止函数修改列表)
        - [传递任意数量的实参](#传递任意数量的实参)
        - [使用任意数量的关键字实参](#使用任意数量的关键字实参)
    - [将函数存储在模块中](#将函数存储在模块中)
        - [导入整个模块](#导入整个模块)
        - [导入特定函数](#导入特定函数)
        - [使用as给函数指定别名](#用as给函数指定别名)
        - [使用as给模块指定别名](#用as给模块指定别名)
        - [导入模块中的所有函数](#导入模块中的所有函数)
    - [函数编写指南](#函数编写指南)
- [类](#类)
    - [lalala]()
        


---
<a id = "函数"></a>
## 函数

---

<a id = "规范"></a>
### 规范：

函数名底下用三个单引号的注释，告知看源码的人该函数的作用。

```
def favoriate_book(title):
    '''显示最喜欢的书籍的函数！'''
    print "One of my favoriate book is %s!" %title
```

当然，还可以在程序段任意位置加入注释以让浏览你程序的人更快速明白你的意图。


---
<a id = "传递参数"></a>
### 传递参数

<a id = "默认值"></a>
#### 默认值：

定义函数的时候，可以给每个形参指定默认值。当我们给实参的时候，函数将使用指定的实参，当我们不给实参的时候，函数使用默认值。

**注意**：

使用默认值时，在形参列表中必须 _先列出没有默认值的形参，再列出有默认值的实参_ 。比如：

```
def animals(a_name, a_type = "dog"):
    '''显示宠物信息'''
    print "I have a " + a_type + ", It name is " + a_name +"!"

animals("cat","dada")
animals("duo")
```


<a id ="title"></a>
#### title()

处理首字母大写，字符串可以调用。


<a id = "实现实参可选"></a>
#### 实现实参可选

可以用**空字符**实现实参可选，比如：

```
def get_format_name(first_name, last_name, middle_name = ""):
    if middle_name:
        full_name = first_name + " " + middle_name + " " + last_name
    else:
        full_name = first_name + " " + last_name
    return full_name.title()

musician = get_format_name("little1","little2")
print musician

musician = get_format_name("big1","big2","big3")
print musician
```

---
<a id = "传递列表"></a>
### 传递列表

<a id = "禁止函数修改列表"></a>
#### 禁止函数修改列表

将列表传递给函数后，函数就可对其进行修改。在函数中对这个列表所做的任何修改都是永久性的，这让你能够高效地处理大量的数据。

若要禁止，可以利用**切片技巧**：
**切片表示法`[:]`创建列表的副本**。比如：

```
names = ["aaaaaa","bbbbb","ccccc"]
def list_exampla(names,ages):
    '''处理姓名和年龄列表'''
    for name in names:
        names.pop()
        print names
    print "this is a example!"
list_exampla(names[:],18)
print names
```

这个函数处理的就是names这个列表的副本，而不是names列表的本身。

**注意：**

虽然向函数传递列表的副本可保留原始列表的内容，但除非有充分的理由需要传递副本，
否则还是应该将原始列表传递给函数，因为让函数使用现成列表可避免花时间和内存创
建副本，从而提高效率，在处理大型列表时尤其如此。


<a id = "传递任意数量的实参" ></a>
#### 传递任意数量的实参

若你预先不知道函数将会处理多少实参，Python的函数调用可以收集任意数量的实参来满足这种需求。比如：

```
def make_pizza(*toppings):
    print toppings
make_pizza("a")
make_pizza("b","c")
```

形参名`*toppings`中的星号让Python创建一个名为toppings的空元组，并将收到的所有值都封装到这个元组中。

函数体内的print语句通过生成输出来证明Python能够处理 使用一个值调用函数的情形，也能处理使用三个值来调用函数的情形。

它以类似的方式处理不同的调用，注意，Python将实参封装到一个**元组**中，即便函数只收到一个值也如此，会输出这样：
```
('a',)
('b', 'c')
```

我们可以配合for语句进行遍历输出，但注意生成元组时是无序的。


<a id = "使用任意数量的关键字实参"></a>
#### 使用任意数量的关键字实参

有时候，需要接受任意数量的实参，但预先不知道传递给函数的会是什么样的信息。

在这种情况下，可将函数编写成能够接受**任意数量的键—值对**——调用语句提供了多少就接受多少。

一个这样的示例是创建用户简介:你知道你将收到有关用户的信息，但不确定会是什么样的信息。
在下面的示例中，函数接受名和姓，同时还接受**任意数量**的关键字实参:

```
def build_profile(first,last,**user_info):
    '''创建字典，包含用户信息！'''
    profile = {}
    profile["first_name"] = first
    profile["last_name"] = last
    for key,value in user_info.items():
        profile[key] = value
    return profile
user_profile = build_profile("aaaa","bbbb",gender = "male",age = "18")
print user_profile
```

函数的定义要求提供名和姓，同时允许用户根据需要提供任意数量的名称—值对。

形参`**user_info`中的两个星号让Python创建一个名为user_info的空字典，并将收到的所有名称—值对都封装到这个字典中。

在这个函数中，可以像访问其他字典那样访问user_info中的名称—值对。

以上例子打印结果为：
```
{'gender': 'male', 'first_name': 'aaaa', 'last_name': 'bbbb', 'age': '18'}
```

编写函数时，你可以以各种方式混合使用位置实参、关键字实参和任意数量的实参。
知道这些实参类型大有裨益，因为阅读别人编写的代码时经常会见到它们。
要正确地使用这些类型的实参并知道它们的使用时机，需要经过一定的练习。

---
<a id = "将函数存储在模块中"></a>
### 将函数存储在模块中 

函数的优点之一是，使用它们可将代码块与主程序分离。

通过给函数指定描述性名称，可让主程序容易理解得多。你还可以更进一步，将函数存储在被称为模块的独立文件中，再将模块导入到主程序中。
`import`语句允许在当前运行的程序文件中使用模块中的代码。

通过将函数存储在独立的文件中，可隐藏程序代码的细节，将重点放在程序的高层逻辑上。这还能让你在众多不同的程序中重用函数。

将函数存储在独立文件中后，可与其他程序员共享这些文件而不是整个程序。知道如何导入函数还能让你使用其他程序员编写的函数库。

<a id ="导入整个模块"></a>
#### 导入整个模块

比如你在`test.py`这个文件里写python程序，你想保证你这个文件里的代码简洁清晰，想把函数写在另一个文件里，这是可以的。
最简单初始的方法就是整体导入。

1. 在与`test.py`**相同的文件夹(同一目录)**里创建一个python文件（后缀为py的文件），用于写函数。

2. 比如你这个用于写函数的文件名称为`testFun.py`，你在里面定义了这样一个函数：
```
def test_print(some_message):
    '''打印传入的信息'''
    print some_message 
```

3. 导入整个模块的方法是，你在`test.py`文件中用整体导入语句：
```
import testFun #使用需要导入的文件名，进行整体导入
testFun.test_print("abc") #直接用导入的文件名，然后点语法+函数名就可直接使用。
```

<a id ="导入特定函数"></a>
#### 导入特定函数

* 方法是使用这样形式的语句：`from module_name import function_name`

还拿上面的例子说，我先把`testFun.py`文件加一个函数：
```
def test_print(some_message):
    '''打印传入的信息'''
    print some_message
def test_another_print(some_message):
    '''打印另一条传入的信息'''
    print "Another " + some_message
```

这时候你在`test.py`文件中使用上面给出的形式：
```
from testFun import test_another_print #调用testFun模块中的test_another_print
testFun.test_print("abc")  #错误语句
test_another_print("aaaa") #正确语句
```

如果你还留着上面整体导入的调用函数的语句，Python会给你报这样一个错误：
```
NameError: name 'testFun' is not defined
```

意思是testFun这个没有被定义。

或者如果你调用第一个函数：
```
test_print("abc") #这个语句是正确的
```

但它也会给你报错：
```
NameError: name 'test_print' is not defined
```

也是告诉你test_print，没有定义。你会觉得明明在写函数的文件里了啊。

造成这两个问题的原因相同：
**因为这个导入函数的语法只导入特定的函数，只能调用导入的函数，不能使用未导入的函数，
并且只需要函数名即可，也不需要像导入整体一样使用模块名和点语法。**

* 看到这你们也许会有疑问，一次只导入一个函数岂不效率低下？Python是考虑到这个问题的，所以有多函数一起导入的方法：
```
from module_name import function_name1，function_name2, function_name3
```

把函数名用逗号隔开即可。


<a id = "用as给函数指定别名"></a>
#### 使用`as`给函数指定别名

如果要导入的函数的名称**可能与程序中现有的名称冲突**，或者函数的名称太长，可指定简短而独一无二的别名 ——函数的另一个名称，类似于外号。
要给函数指定这种特殊外号，需要在导入它时这样做：
`from module_name import function_name as fn`

这个`fn`就是外号，这时候调用函数的时候使用外号就行。再用上面的例子：
```
from testFun import test_another_print as t_a_p #给函数指定别名t_a_p
t_a_p("aaaaa") #这时别名就生效了
```
这时你再用：`test_another_print（"aaaaa"）`也会报`NameError`的错误。
意味着指定别名之后只能用别名来调用函数。


<a id = "用as给模块指定别名"></a>
#### 使用`as`给模块指定别名

与给函数指定别名类似，只需这个语句即可：
```
import module_name as mn
```

这个mn就是模块的别名，所以这时候与导入整体的调用类似，只不过把模块名称换成别名即可，函数还是用点语法来调用。

**好处**：

这样不仅能使代码更简洁，还可以让你不再关注模块名，而专注于描述性的函数名。
这些函数名明确地指出了函数的功能，对理解代码而言，它们 比模块名更重要。


<a id = "导入模块中所有函数"></a>
#### 导入模块中的所有函数

使用星号`*`运算符可让Python导入模块中的所有函数:
```
from testFun import * #从testFun模块导入所有的函数
```

`import`语句中的星号让Python将模块`testFun`中的每个函数都复制到这个程序文件中。
由于导入了每个函数，可通过**函数名称**来调用每个函数，而**无需使用句点表示法**。

然而，使用并非自己编写的**大型模块**时，最好不要采用这种导入方法。
如果模块中有函数的名称与你的项目中使用的名称相同，可能导致意想不到的结果：
Python可能遇到多个名称相同的函数或变量，进而覆盖函数，而不是分别导入所有的函数。

**最佳**的做法是，要么只导入你**需要使用的函数**，要么导入**整个模块并使用句点表示法**。这能让代码更清晰，更容易阅读和理解。


<a id = "函数编写指南"></a>
### 函数编写指南

* 应给函数指定描述性名称，且只在其中使用小写字母和下划线。描述性名称可帮助你和别人明白代码想要做什么。给模块命名时也应遵循上述约定。

* 每个函数都应包含简要地阐述其功能的注释，该注释应紧跟在函数定义后面，并采用文档字符串格式。
文档良好的函数让其他程序员只需阅读文档字符串中的描述就能够使用它:
他们完全可以相信代码如描述的那样运行，只要知道函数的名称、需要的实参以及返回值的类型，就能在自己的程序中使用它。

* 给形参指定默认值时，等号两边不要有空格:
```
def function_name(parameter_0, parameter_1="default value")
```

* 对于函数调用中的关键字实参，也应遵循这种约定:
```
 function_name(value_0, parameter_1="value")
```

* 如果形参过长，单行放不下，可以灵活的运用回车和空格来把形参放成一种清晰的形式，区分开函数体。比如:
```
def function_name(
        parameter_0, parameter_1, parameter_2,
        parameter_3, parameter_4, parameter_5)：
    function body... 
```

* 如果程序或模块包含多个函数，可使用两个空行将相邻的函数分开，这样将更容易知道前一个函数在什么地方结束，下一个函数从什么地方开始。

* 所有的`import`语句都应放在文件开头，唯一例外的情形是，在文件开头使用了注释来描述整个程序。

**简单小结：**

* 函数让你编写代码一次后，想重用它们多少次就重用多少次。需要运行函数中的代码时，只需编写一行函数调用代码，就可让函数完成其工作。
需要修改函数的行为时，只需修改一个代码块，而所做的修改将影响调用这个函数的每个地方。

* 使用函数让程序更容易阅读，而良好的函数名概述了程序各个部分的作用。相对于阅读一系列的代码块，阅读一系列函数调用让你能够更快地明白程序的作用。

* 函数让代码更容易测试和调试。如果程序使用一系列的函数来完成其任务，而其中的每个函数都完成一项具体的工作，测试和维护起来将容易得多：
你可编写分别调用每个函数的程序，并测试每个函数是否在它可能遇到的各种情形下都能正确地运行。


---
<a id = "类"></a>
## 类










