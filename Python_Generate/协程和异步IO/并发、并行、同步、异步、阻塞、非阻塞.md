## 并发
并发是指在一个时间段内，有几个程序在同一个cpu上运行，但是任意时刻只有一个程序在cpu上运行
## 并行
并行是指任意时刻点上，有多个程序同时运行在多个cpu上
## 同步
同步是指代码调用IO操作时，必须等待IO操作完成才返回的调用方式
## 异步
是指代码调用IO操作时，不必等待IO操作完成就返回的调用方式
## 阻塞
阻塞是指调用函数时候当前线程被挂起
## 非阻塞
非阻塞是指调用函数时候当前线程不会被挂起，而是立即返回

## 解释
同步异步是消息通信的一种机制，我可以把操作看做一种消息，
我们调用这个操作的时候，发一个消息给另外一个线程，或者协程，
让它执行某一个操作，我再提交我的数据之后我立马得到我的future，
后面我就可以通过future拿到我的结果，事实上是消息之间一种通信机制

阻塞非阻塞是不一样的，它是函数调用的一种机制

## C10K的问题
C10K是一个在1999年被提出来的技术挑战
如何在一颗1GHz CPU， 2G内存，1gbps网络环境下，让单台服务器
同时为1万个客户端提供FTP服务

## Unix下五中I/O模型
    递进发展关系
### 阻塞式I/O
### 非阻塞式I/O
### I/O复用
### 信号驱动式I/O
### 异步I/O（POSIX的aio_系列函数）

## 补充
connect方法是立即返回的，但是不代表三次握手立即完成
阻塞是不会消耗cpu的

## select、poll、epoll
select，poll，epoll都是IO多路复用的机制。
IO多路复用就是通过一种机制，一个进程可以监视多个描述符，
一旦某个描述符就绪（一般是读就绪或者写就绪），
能够通知程序进行相应的读写操作。
但select，poll，epoll本质上都是同步IO，
因为他们都需要在读写事件就绪后自己负责进行读写，
也就是说这个读写过程是阻塞的。
而异步IO则无需自己负责进行读写，
异步IO的实现会负责把数据从内核拷贝到用户空间。

### select
select函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，知道有描述符就绪（有数据可读、可写或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。
select目前几乎在所有的平台上支持，其良好的跨平台支持也是它的一个优点。
select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在
Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但是这样也会造成效率的降低。

### poll
    查询效率稍高
不同与select使用三个位图来表示三个fdset的方式，poll使用一个pollfd的指针实现。
pollfd结构包含了要监视的event和发生的event，不再使用select“参数-值”
传递的方式。同时，pollfd并没有最大数量限制（但是数量过大后性能也是会下降）。和select函数一样，poll返回后，需要轮询pollfd来获取就绪的描述符。
从上面看，select和poll都需要在返回后，通过遍历文件描述符来获取已经就绪
的socket。事实上，同时连接的大量客户端在同一时刻可能只有很少的处于就绪
状态，因此随着监视的描述符数量的增长，其效率也会线性下降。

### epoll，只在linux下支持
epoll是在2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。

### 补充说明
- epoll并不代表一定比select好
    - 在并发高的情况下，链接活跃度不是很高，epoll比select好
    - 并发性不高，同时连接很活跃（如游戏，连上基本不会总主动断），select比epoll好。
